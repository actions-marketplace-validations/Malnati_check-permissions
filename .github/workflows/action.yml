<!-- .github/workflows/action.yml -->

name: "check-permissions"
description: "Coleta configura√ß√µes de merge e prote√ß√£o de branch, gera checklist e comenta na PR."

inputs:
  token:
    description: "GitHub token (ex.: secrets.GITHUB_TOKEN)"
    required: true
  base_branch:
    description: "Nome do branch base a ser verificado (ex.: main, staging)"
    required: true
  pr_number:
    description: "N√∫mero da Pull Request a ser comentada"
    required: true

outputs:
  message_checklist:
    description: "Checklist em Markdown com configura√ß√µes de merge e prote√ß√£o do branch base."
    value: ${{ steps.build-checklist.outputs.message_checklist }}

runs:
  using: "composite"
  steps:
    - id: fetch-permissions
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        BASE_BRANCH: ${{ inputs.base_branch }}
      run: |
        set -euo pipefail

        GITHUB_API_URL="https://api.github.com"

        REPO_RESPONSE="$(curl -sS \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github+json" \
          "$GITHUB_API_URL/repos/$GITHUB_REPOSITORY")"

        TMP_PROTECTION="$(mktemp)"

        BRANCH_PROT_STATUS="$(curl -sS \
          -o "$TMP_PROTECTION" \
          -w '%{http_code}' \
          -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github+json" \
          "$GITHUB_API_URL/repos/$GITHUB_REPOSITORY/branches/$BASE_BRANCH/protection")"

        PROTECTION_RESPONSE="$(cat "$TMP_PROTECTION" || echo '')"
        rm -f "$TMP_PROTECTION" || true

        {
          printf 'repo_json<<EOF\n%s\nEOF\n' "$REPO_RESPONSE"
          printf 'protection_json<<EOF\n%s\nEOF\n' "$PROTECTION_RESPONSE"
          echo "branch_prot_status=$BRANCH_PROT_STATUS"
        } >> "$GITHUB_OUTPUT"

    - id: build-checklist
      shell: bash
      env:
        REPO_JSON: ${{ steps.fetch-permissions.outputs.repo_json }}
        PROTECTION_JSON: ${{ steps.fetch-permissions.outputs.protection_json }}
        BRANCH_PROT_STATUS: ${{ steps.fetch-permissions.outputs.branch_prot_status }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        GITHUB_OUTPUT: ${{ env.GITHUB_OUTPUT }}
      run: |
        set -euo pipefail

        python - << 'PY'
        import json
        import os

        def emoji(val):
            if val is True:
                return "‚úÖ"
            if val is False:
                return "‚ùå"
            if val is None:
                return "‚ùî"
            return "‚úÖ" if val else "‚ùå"

        repo_raw = os.environ.get("REPO_JSON", "") or "{}"
        prot_raw = os.environ.get("PROTECTION_JSON", "") or "{}"
        status = os.environ.get("BRANCH_PROT_STATUS", "")
        base_branch = os.environ.get("BASE_BRANCH", "")

        try:
            repo = json.loads(repo_raw)
        except Exception:
            repo = {}

        allow_rebase = repo.get("allow_rebase_merge")
        allow_squash = repo.get("allow_squash_merge")
        allow_merge_commit = repo.get("allow_merge_commit")
        allow_auto_merge = repo.get("allow_auto_merge")
        delete_branch_on_merge = repo.get("delete_branch_on_merge")
        default_branch = repo.get("default_branch")

        linear_history = None
        required_status = None
        strict_status = None
        required_approving = None
        enforce_admins = None
        restrictions = None

        if status == "200":
            try:
                prot = json.loads(prot_raw)
            except Exception:
                prot = {}
            else:
                linear = prot.get("required_linear_history")
                if isinstance(linear, dict):
                    linear_history = linear.get("enabled")
                elif isinstance(linear, bool):
                    linear_history = linear

                rs = prot.get("required_status_checks")
                if isinstance(rs, dict):
                    checks = rs.get("checks")
                    contexts = rs.get("contexts")
                    required_status = bool(checks or contexts)
                    strict_status = rs.get("strict")

                rpr = prot.get("required_pull_request_reviews")
                if isinstance(rpr, dict):
                    required_approving = rpr.get("required_approving_review_count")

                ea = prot.get("enforce_admins")
                if isinstance(ea, dict):
                    enforce_admins = ea.get("enabled")
                elif isinstance(ea, bool):
                    enforce_admins = ea

                rest = prot.get("restrictions")
                if isinstance(rest, dict):
                    restrictions = bool(
                        rest.get("users") or rest.get("teams") or rest.get("apps")
                    )

        lines = []
        lines.append("üìã Lista de checagem de merge e prote√ß√£o de branch:")
        lines.append("")
        lines.append("**Configura√ß√£o de merge do reposit√≥rio:**")
        lines.append(f"- Rebase merge habilitado: {emoji(allow_rebase)}")
        lines.append(f"- Squash merge habilitado: {emoji(allow_squash)}")
        lines.append(f"- Merge commit habilitado: {emoji(allow_merge_commit)}")
        lines.append(f"- Auto-merge habilitado: {emoji(allow_auto_merge)}")
        lines.append(f"- Deletar branch no merge: {emoji(delete_branch_on_merge)}")
        if default_branch:
            lines.append(f"- Branch padr√£o do reposit√≥rio: `{default_branch}`")

        if status == "200":
            lines.append("")
            lines.append(f"**Prote√ß√£o do branch base `{base_branch}`:**")
            lines.append(f"- Hist√≥rico linear obrigat√≥rio: {emoji(linear_history)}")
            if required_status is not None:
                lines.append(f"- Status checks obrigat√≥rios: {emoji(required_status)}")
                if strict_status is not None:
                    lines.append(f"  - Exigir branch atualizado para merge: {emoji(strict_status)}")
            if required_approving is not None:
                count = required_approving or 0
                lines.append(f"- Reviews obrigat√≥rios: {count} aprova√ß√£o(√µes)")
            if enforce_admins is not None:
                lines.append(f"- Regras v√°lidas tamb√©m para admins: {emoji(enforce_admins)}")
            if restrictions is not None:
                lines.append(f"- Restri√ß√£o de quem pode pushar: {emoji(restrictions)}")
        else:
            lines.append("")
            lines.append(f"‚ö†Ô∏è N√£o foi poss√≠vel ler a prote√ß√£o do branch `{base_branch}` (status HTTP {status}).")

        msg = "\n".join(lines)

        github_output = os.environ.get("GITHUB_OUTPUT")
        if github_output:
            with open(github_output, "a", encoding="utf-8") as fh:
                fh.write("message_checklist<<EOF\n")
                fh.write(msg)
                fh.write("\nEOF\n")
        else:
            print(msg)
        PY

    - id: comment-checklist
      uses: Malnati/pr-comment@v1
      with:
        token: ${{ inputs.token }}
        pr_number: ${{ inputs.pr_number }}
        header_actor: ${{ github.actor }}
        header_title: "üìã Checklist de prote√ß√£o de branch"
        header_subject: Regras aplicadas ao branch base ${{ inputs.base_branch }}
        body_message: ${{ steps.build-checklist.outputs.message_checklist }}
        body_scope: ""
        body_todo: ""
        footer_result: "Checklist gerada automaticamente."
        footer_advise: "Revise as regras antes de ajustar a estrat√©gia de merge."
